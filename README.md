# Функциональное программирование: Пишем компилятор!

Цель этой лабораторной работы - придумать свой собственный функциональный язык программирования и разработать для него интерпретатор или компилятор.

Вы можете выполнить эту лабораторную работу в группе из 2 или 3 человек (или больше - но это требует одобрения преподавателя):

* 2 человека - компилятор/интерпретатор + примеры программ + краткая документация в README.md (вы можете заменить этот файл своей собственной документацией)
* 3 человека - компилятор/интерпретатор + примеры программ + более подробная документация на GitHub Pages
* 3 и более человек - помимо вышеуказанного, может включать следующее:
  - IDE в браузере
  - Поддержка Jupyter Notebook
  - Трансляция в JavaScript, чтобы можно было выполнять программу в браузере
  - Расширения для VS Code
 
## Авторы

Не забудьте упомянуть свою команду в файле README.md, указав также, кто что делал. Также файл README.md должен включать краткое руководство по вашему языку и некоторые короткие примеры кода.

Имя | Роль в проекте
------------------|---------------------
 Деревянко Екатерина| Писала парсер
 Леленков Никита| Писал интерпретатор
 Озеров Владимир| Писал документацию

Мы использовали ChatGPT для помощи в устранении ошибок в коде, это сильно ускорило процесс.
Документацию можно найти по ссылке, там же есть примеры программ: https://toomanyfandoms.github.io/FuncProg/

Пример программы факториала:
```
.... .. .-.. . / .- ... .. -- -. / -... / 1 / .- / 1 / ...- .- .-. / ...- / 1 / --.- / .- / .-- .... .. .-.. . / ...- / -... / .- ... ... .. -- -. / .- ... / ...- / - / -.. --- / .- / .- ... ... .. -- -. / ...- / ...- / .- ... / ...- / .--. .-. --- -.. / -.. --- / .- / ...- / -... / ...- / -.. --- / - / .-. .-.. . - / .- / .- / -... / .- / -... --- -.. -.-- / . -. -..
```

## Задача

Ваша цель - изобрести и реализовать собственный функциональный язык программирования. Требования:

* Он должен тесно следовать парадигме функционального программирования, на основе либо [лямбда-исчисления](https://en.wikipedia.org/wiki/Lambda_calculus), либо [комбинаторной логики](https://en.wikipedia.org/wiki/Combinatory_logic).
* Он должен быть более или менее универсальным, т.е. реализовывать рекурсию. В идеале - полным по Тьюрингу.
* Как минимум, язык должен позволять запрограммировать функцию для расчета факториала.

> Имейте в виду, что написание парсеров - это утомительная задача, поэтому постарайтесь сделать синтаксис языка как можно проще.

Для вдохновения:

* Изучите [LISP](https://books.ifmo.ru/file/pdf/1918.pdf) - язык программирования с очень простым синтаксисом.
* Комбинаторные парсеры и библиотеку [fparsec](https://www.quanttec.com/fparsec/), если вы хотите реализовать язык с более сложным синтаксисом.
* [Top-Down Parser на F#](https://github.com/fholm/Vaughan).
* Интересный блог пост о [парсинге на F#](https://www.erikschierboom.com/2016/12/10/parsing-text-in-fsharp/).
* Парсинг с использованием инструментов [FsLex и FsYacc](https://realfiction.net/posts/lexing-and-parsing-in-f/) (не рекомендуется).
* Реализация [Scheme в F#](https://github.com/AshleyF/FScheme) - вы можете ознакомиться с этим проектом для вдохновения, но не заимствуйте код оттуда!

## Критерии оценки

* Универсальность
* Примеры программ (включая факториал, но не ограничиваясь им)
* Оригинальность и красота синтаксиса
* Документированность
* Красота реализации

Предпочтительный язык реализации - F#.

В документации явно укажите, какие функции языка вы реализовали:

* [ ] Именованные переменные (`let`)
* [ ] Рекурсия
* [ ] Ленивое вычисление
* [ ] Функции
* [ ] Замыкания
* [ ] Библиотечные функции: ввод-вывод файлов
* [ ] Списки / Последовательности
* [ ] Библиотечные функции: списки/последовательности

## Репозиторий

Вам необходимо работать над кодом в репозитории GitHub Classroom. После завершения задачи **настоятельно рекомендуется** форкнуть этот код в свои собственные аккаунты GitHub, чтобы он служил вашим портфолио.

## Пошаговая работа

Поскольку проект довольно большой, его нужно делать поэтапно, загружая ваш код в GitHub на каждом этапе:

* Этап 1: Разработка абстрактного синтаксического дерева и парсера для вашего языка + одна примерная программа.
* Этап 2: Разработка интерпретатора/компилятора для вашего языка.
* Этап 3: Написание примеров программ и документации.

> Конечно, вы можете изменять язык на более поздних этапах, если посчитаете это нужным.
